"use strict";
import { APP_CONFIG } from '../config/default.config.js';
import MergeDeep from '../utils/mergeDeep.js';
import Swal from 'sweetalert2';
import axios from 'axios';
import TokenManager from '../managers/TokenManager.js';


export default class ApiService {
    constructor(customConfig = {}) {
        // Varsayƒ±lan API konfig√ºrasyonu ile customConfig'i derinlemesine birle≈ütiriyoruz.
        this.apiConfig = MergeDeep(APP_CONFIG.API, customConfig);

        this.axios = axios.create({
            baseURL: this.apiConfig.baseURL,
            headers: this.apiConfig.headers,
            timeout: this.apiConfig.timeout
        });

        this.setupInterceptors();
    }

    setupInterceptors() {
        // ƒ∞stek √ñncesi ƒ∞≈ülemler
        this.axios.interceptors.request.use(
            (config) => {
                // Token ekle
                TokenManager.addAuthHeader(config);
                // Rate limiting kontrol√º
                if (this.apiConfig.rateLimiting && this.apiConfig.rateLimiting.enabled) {
                    if (!this.checkRateLimit()) {
                        return Promise.reject({ message: 'Rate limit a≈üƒ±ldƒ±' });
                    }
                }
                // G√ºvenlik header'larƒ±nƒ± ekle
                if (this.apiConfig.security && this.apiConfig.security.enableSecurityHeaders) {
                    config.headers = { ...this.apiConfig.security.headers, ...config.headers };
                }
                // CSRF token otomatik algƒ±lama ve ekleme
                if (this.apiConfig.csrf && this.apiConfig.csrf.autoDetect) {
                    const csrfToken = this.getCookie(this.apiConfig.csrf.cookieName);
                    if (csrfToken) {
                        config.headers[this.apiConfig.csrf.headerName] = csrfToken;
                    }
                }
                return config;
            },
            (error) => Promise.reject(error)
        );

        // Yanƒ±t ƒ∞≈ülemleri
        this.axios.interceptors.response.use(
            (response) => {
                // Ba≈üarƒ± durumunda, ba≈üarƒ± y√∂netimi i≈ülemlerini yapar.
                this.handleSuccess(response);
                return response;
            },
            (error) => {
                // Hata durumunda, hata y√∂netimi i≈ülemlerini yapar.
                this.handleError(error);
                return Promise.reject(error);
            }
        );
    }

    /**
     * ƒ∞stekleri ger√ßekle≈ütiren metottur.
     * Ekstra parametreler (preventRedirect, tokenKey, tokenName, clearToken, setTokenKey, setTokenName) 
     * istek konfig√ºrasyonuna dahil edilir.
     *
     * @param {object} config Axios istek konfig√ºrasyonu
     * @returns {Promise} Axios isteƒüinin Promise nesnesi
     */
    async request(config) {
        try {
            const requestConfig = {
                ...config,
                // tokenKey: config.tokenKey ?? false,
                // tokenName: config.tokenName ?? false,
                // clearToken: config.clearToken ?? false,
            };
            return await this.axios(requestConfig);
        } catch (error) {
            throw error;
        }
    }

    handleSuccess(response) {

        // onSuccess callback'ini √ßaƒüƒ±rƒ±yoruz. D√∂n√º≈ü deƒüeri false deƒüilse default i≈ülemler y√ºr√ºt√ºl√ºr.
        let onSuccessResult = true;

        if(typeof response.config.actions?.onSuccess === 'function'){
            const result = response.config.actions.onSuccess(response);
            onSuccessResult = result === false ? false : true;
        }

        // Eƒüer istek konfig√ºrasyonunda onSuccess callback tanƒ±mlƒ±ysa, √ßaƒüƒ±rƒ±yoruz.
        if (onSuccessResult !== false) {
            TokenManager.processTokenResponse(response.config, response.data);

            // G√ºvenli eri≈üim i√ßin optional chaining kullanƒ±yoruz.
            // Eƒüer response.data.message tanƒ±mlƒ± ise onu, deƒüilse response.config.success?.message kullanƒ±lƒ±r.
            const successMessage = response.data.message ??
                response.config.actions?.success?.message ??
                this.apiConfig.success?.message ??
                "ƒ∞stek ba≈üarƒ±lƒ± bir ≈üekilde ger√ßekle≈ütirildi.";

            if (successMessage) {
                if ((response.config.sweetalert2 ?? this.apiConfig.sweetalert2 ?? true) === false) {
                    console.log(successMessage);
                } else {
                    this.showSuccess(successMessage);
                }
            }

            let preventRedirect = response.config.actions?.success?.preventRedirect ?? response.config.preventRedirect 
            ?? this.apiConfig.actions?.success?.preventRedirect ?? this.apiConfig.preventRedirect ?? false;
            let redirect = response.config.actions?.success?.redirect ?? this.apiConfig.success?.redirect ?? false;
            // Eƒüer ba≈üarƒ± durumunda y√∂nlendirme (redirect) tanƒ±mlƒ±ysa ve istek redirect'i engellenmemi≈üse y√∂nlendiriyoruz.
            if (redirect && !preventRedirect) {
                setTimeout(() => {
                    window.location.href = redirect;
                }, APP_CONFIG.UI?.notifications?.timer ?? 2000);
            }
        }

        return response;
    }

    /**
     * Global hata y√∂netimi:
     * default.config.js'teki APP_CONFIG.API.errors tanƒ±mlamalarƒ±nƒ± kullanarak
     * hata durumunda token temizleme, mesaj g√∂sterme ve y√∂nlendirme i≈ülemlerini ger√ßekle≈ütirir.
     */
    handleError(error) {

        // Hata durumunda, hata y√∂netimi i≈ülemlerini yapar.
        const { status, data } = error.response || {};
        const errorConfig = this.apiConfig.errors?.[status] || {};
        const requestConfig = error.response?.config || {};

        // onError callback'ini √ßaƒüƒ±rƒ±yoruz. D√∂n√º≈ü deƒüeri false deƒüilse default i≈ülemler y√ºr√ºt√ºl√ºr.
        let onErrorResult = true;

        if(typeof requestConfig.actions?.onError === 'function'){
            const result = requestConfig.actions.onError(error);
            onErrorResult = result === false ? false : true;
        }

        if (onErrorResult !== false) {

            // Yanƒ±t geldiƒüinde, token kaydetme veya temizleme i≈ülemini yapar.
            if (requestConfig) {
                TokenManager.processTokenResponse(requestConfig, data);
            }

            // Konfig√ºrasyonda tanƒ±mlƒ± hata mesajƒ± varsa onu kullanƒ±yoruz.
            const errorMessage = requestConfig.actions?.errors?.[status]?.message ??
                requestConfig.actions?.errors?.message ??
                errorConfig?.message ??
                this.apiConfig.errors?.message;
            const errorStatus = error.response?.status;

            // Eƒüer sweetalert2 kullanƒ±lmƒ±yorsa konsola loglama yapƒ±lƒ±yor; aksi halde uyarƒ± g√∂steriliyor.
            if ((requestConfig.sweetalert2 ?? this.apiConfig.sweetalert2 ?? true) === false) {
                if (errorMessage) {
                    console.log(errorMessage + ' ' + errorStatus);
                } else {
                    switch (status) {
                        case 400:
                            console.warn(data?.message || 'Bad Request ' + errorStatus);
                            break;
                        case 401:
                            localStorage.removeItem(this.apiConfig.tokenName);
                            console.error(data?.message || 'Oturum s√ºresi doldu ' + errorStatus);
                            break;
                        case 403:
                            console.error(data?.message || 'Bu i≈ülem i√ßin yetkiniz yok ' + errorStatus);
                            break;
                        case 422:
                            console.error('Validasyon Hatalarƒ±: ' + errorStatus);
                            if (data?.errors) {
                                console.group('Alan Bazlƒ± Hatalar:');
                                // Her bir alanƒ±n adƒ±nƒ± ve hata mesajlarƒ±nƒ± d√ºzenli ≈üekilde g√∂ster
                                Object.entries(data.errors).forEach(([field, messages]) => {
                                    console.error(`üî¥ ${field} alanƒ±:`);
                                    if (Array.isArray(messages)) {
                                        messages.forEach(message => {
                                            console.error(`   ‚Üí ${message}`);
                                        });
                                    } else {
                                        console.error(`   ‚Üí ${messages}`);
                                    }
                                });
                                console.groupEnd();
                            }
                            break;
                        case 429:
                            console.warn('√áok fazla istek g√∂nderildi. L√ºtfen bekleyin. ' + errorStatus);
                            break;
                        case 500:
                            console.error('Sunucu hatasƒ± olu≈ütu ' + errorStatus);
                            break;
                        default:
                            console.error('Bir hata olu≈ütu');
                    }
                }
            } else {
                if (errorMessage) {
                    Swal.fire({
                        icon: 'error',
                        title: errorStatus,
                        text: errorMessage,
                        ...APP_CONFIG.UI?.notifications ?? {}
                    });
                } else {
                    switch (status) {
                        case 400:
                            this.showWarning(data?.message || 'Bad Request ' + errorStatus);
                            break;
                        case 401:
                            localStorage.removeItem(this.apiConfig.tokenName);
                            this.showError(data?.message || 'Oturum s√ºresi doldu ' + errorStatus);
                            break;
                        case 403:
                            this.showError(data?.message || 'Bu i≈ülem i√ßin yetkiniz yok ' + errorStatus);
                            break;
                        case 422:
                            this.showValidationErrors(data?.errors);
                            break;
                        case 429:
                            this.showWarning('√áok fazla istek g√∂nderildi. L√ºtfen bekleyin.');
                            break;
                        case 500:
                            this.showError('Sunucu hatasƒ± olu≈ütu ' + errorStatus);
                            break;
                        default:
                            this.showError('Bir hata olu≈ütu ' + errorStatus);
                    }
                }
            }

            let preventRedirect = requestConfig.actions?.errors?.preventRedirect ?? requestConfig.preventRedirect ?? 
            this.apiConfig.actions?.errors?.preventRedirect ?? this.apiConfig.preventRedirect ?? false; 
            let redirect = requestConfig.actions?.errors?.[status]?.redirect ?? requestConfig.actions?.errors?.redirect 
            ?? this.apiConfig.errors?.[status]?.redirect ?? this.apiConfig.errors?.redirect ?? false;
            
            // Eƒüer hata durumunda y√∂nlendirme (redirect) tanƒ±mlƒ±ysa ve istek redirect'i engellenmemi≈üse y√∂nlendiriyoruz.
            if (redirect && !preventRedirect) {
                setTimeout(() => {
                    window.location.href = redirect;
                }, APP_CONFIG.UI?.notifications?.timer ?? 2000);
            } 
        }

        return error;
    }


    getCookie(name) {
        if (typeof document === 'undefined') return null;
        const value = `; ${document.cookie}`;
        const parts = value.split(`; ${name}=`);
        if (parts.length === 2) return parts.pop().split(';').shift();
        return null;
    }

    /**
     * Rate limiting kontrol√º:
     * Eƒüer APP_CONFIG.API.rateLimiting.enabled true ise,
     * stratejiye g√∂re; 'token-bucket' veya 'fixed-window' algoritmasƒ±nƒ± uygular.
     */
    checkRateLimit() {
        if (this.apiConfig.rateLimiting && this.apiConfig.rateLimiting.enabled) {
            if (this.apiConfig.rateLimiting.strategy === 'token-bucket') {
                if (!this.tokenBucket) {
                    this.tokenBucket = {
                        tokens: this.apiConfig.rateLimiting.limits.perMinute,
                        lastRefill: Date.now()
                    };
                }
                const now = Date.now();
                const refillInterval = 60000; // 1 dakika
                const elapsed = now - this.tokenBucket.lastRefill;
                if (elapsed > refillInterval) {
                    this.tokenBucket.tokens = this.apiConfig.rateLimiting.limits.perMinute;
                    this.tokenBucket.lastRefill = now;
                }
                if (this.tokenBucket.tokens > 0) {
                    this.tokenBucket.tokens--;
                    return true;
                }
                return false;
            } else if (this.apiConfig.rateLimiting.strategy === 'fixed-window') {
                if (!this.fixedWindow) {
                    this.fixedWindow = {
                        count: 0,
                        windowStart: Date.now()
                    };
                }
                const now = Date.now();
                const fixedWindowDuration = 60000; // 1 dakika
                if (now - this.fixedWindow.windowStart > fixedWindowDuration) {
                    this.fixedWindow.count = 0;
                    this.fixedWindow.windowStart = now;
                }
                if (this.fixedWindow.count < this.apiConfig.rateLimiting.limits.perMinute) {
                    this.fixedWindow.count++;
                    return true;
                }
                return false;
            }
            return true;
        }
        return true;
    }

    showSuccess(message) {
        Swal.fire({
            icon: 'success',
            title: 'Ba≈üarƒ±lƒ±!',
            text: message,
            timer: 2000,
            showConfirmButton: false
        });
    }

    showError(message) {
        Swal.fire({
            icon: 'error',
            title: 'Hata!',
            text: message
        });
    }

    showWarning(message) {
        Swal.fire({
            icon: 'warning',
            title: 'Uyarƒ±!',
            text: message
        });
    }

    showValidationErrors(errors) {
        const errorMessages = Object.values(errors || {}).flat();
        Swal.fire({
            icon: 'error',
            title: 'Validasyon Hatasƒ±',
            html: errorMessages.join('<br>')
        });

        Object.keys(errors || {}).forEach(field => {
            const input = document.querySelector(`input[name="${field}"]`);
            if (input) {
                const wrapper = input.closest('.wrap-input100');
                if (wrapper) {
                    wrapper.classList.add('alert-validate');
                }
            }
        });
    }
}